{"version":3,"file":"workbox-strategies.dev.js","sources":["../_version.js","../StrategyHandler.js","../Strategy.js","../utils/messages.js","../CacheFirst.js","../CacheOnly.js","../plugins/cacheOkAndOpaquePlugin.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:6.1.1'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return (typeof input === 'string') ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * [handle()]{@link module:workbox-strategies.Strategy~handle} or\n * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof module:workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {module:workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     *     [match callback]{@link module:workbox-routing~matchCallback},\n     *     (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * [match callback]{@link module:workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    fetch(input) {\n        return this.waitUntil((async () => {\n            const { event } = this;\n            let request = toRequest(input);\n            if (request.mode === 'navigate' &&\n                event instanceof FetchEvent &&\n                event.preloadResponse) {\n                const possiblePreloadResponse = await event.preloadResponse;\n                if (possiblePreloadResponse) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.log(`Using a preloaded navigation response for ` +\n                            `'${getFriendlyURL(request.url)}'`);\n                    }\n                    return possiblePreloadResponse;\n                }\n            }\n            // If there is a fetchDidFail plugin, we need to save a clone of the\n            // original request before it's either modified by a requestWillFetch\n            // plugin or before the original request's body is consumed via fetch().\n            const originalRequest = this.hasCallback('fetchDidFail') ?\n                request.clone() : null;\n            try {\n                for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                    request = await cb({ request: request.clone(), event });\n                }\n            }\n            catch (err) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownError: err,\n                });\n            }\n            // The request can be altered by plugins with `requestWillFetch` making\n            // the original request (most likely from a `fetch` event) different\n            // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n            const pluginFilteredRequest = request.clone();\n            try {\n                let fetchResponse;\n                // See https://github.com/GoogleChrome/workbox/issues/1796\n                fetchResponse = await fetch(request, request.mode === 'navigate' ?\n                    undefined : this._strategy.fetchOptions);\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Network request for ` +\n                        `'${getFriendlyURL(request.url)}' returned a response with ` +\n                        `status '${fetchResponse.status}'.`);\n                }\n                for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                    fetchResponse = await callback({\n                        event,\n                        request: pluginFilteredRequest,\n                        response: fetchResponse,\n                    });\n                }\n                return fetchResponse;\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error(`Network request for ` +\n                        `'${getFriendlyURL(request.url)}' threw an error.`, error);\n                }\n                // `originalRequest` will only exist if a `fetchDidFail` callback\n                // is being used (see above).\n                if (originalRequest) {\n                    await this.runCallbacks('fetchDidFail', {\n                        error,\n                        event,\n                        originalRequest: originalRequest.clone(),\n                        request: pluginFilteredRequest.clone(),\n                    });\n                }\n                throw error;\n            }\n        })());\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    cacheMatch(key) {\n        return this.waitUntil((async () => {\n            const request = toRequest(key);\n            let cachedResponse;\n            const { cacheName, matchOptions } = this._strategy;\n            const effectiveRequest = await this.getCacheKey(request, 'read');\n            const multiMatchOptions = { ...matchOptions, ...{ cacheName } };\n            cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    logger.debug(`Found a cached response in '${cacheName}'.`);\n                }\n                else {\n                    logger.debug(`No cached response found in '${cacheName}'.`);\n                }\n            }\n            for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n                cachedResponse = (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n            }\n            return cachedResponse;\n        })());\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n        // feature. Consider into ways to only add this behavior if using\n        // precaching.\n        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :\n            null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ?\n                responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n            if (error.name === 'QuotaExceededError') {\n                await executeQuotaErrorCallbacks();\n            }\n            throw error;\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        if (!this._cacheKeys[mode]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    params: this.params,\n                }));\n            }\n            this._cacheKeys[mode] = effectiveRequest;\n        }\n        return this._cacheKeys[mode];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = { ...param, state };\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while (promise = this._extendLifetimePromises.shift()) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve();\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache = (await callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event,\n            })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n","/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof module:workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * [workbox-core]{@link module:workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * [route]{@link module:workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of [response, done] promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string' ?\n            new Request(options.request) :\n            options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                response = await callback({ error, event, request });\n                if (response) {\n                    break;\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            error = waitUntilError;\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {module:workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof module:workbox-strategies.Strategy\n */\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport '../_version.js';\nexport const messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: (response) => {\n        if (response) {\n            logger.groupCollapsed(`View the final response here.`);\n            logger.log(response || '[No response returned]');\n            logger.groupEnd();\n        }\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\nclass CacheFirst extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            }\n            catch (err) {\n                error = err;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\nclass CacheOnly extends Strategy {\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this.cacheName}' ` +\n                    `cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\nclass NetworkFirst extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: this.constructor.name,\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, logs, handler });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({ timeoutId, request, logs, handler });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async () => {\n            // Promise.race() will resolve as soon as the first promise resolves.\n            return await handler.waitUntil(Promise.race(promises)) ||\n                // If Promise.race() resolved with null, it might be due to a network\n                // timeout + a cache miss. If that were to happen, we'd rather wait until\n                // the networkPromise resolves instead of returning null.\n                // Note that it's fine to await an already-resolved promise, so we don't\n                // have to check to see if it's still \"in flight\".\n                await networkPromise;\n        })());\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, handler }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} options.event\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, handler }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        }\n        catch (fetchError) {\n            error = fetchError;\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}'` +\n                        ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\nclass NetworkOnly extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n     * that fail to respond within the timeout will result in a network error.\n     */\n    constructor(options = {}) {\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: '_handle',\n                paramName: 'request',\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [handler.fetch(request)];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ` +\n                    `${this._networkTimeoutSeconds} seconds.`);\n            }\n        }\n        catch (err) {\n            error = err;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport { Strategy } from './Strategy.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\nclass StaleWhileRevalidate extends Strategy {\n    /**\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const logs = [];\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: this.constructor.name,\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = handler\n            .fetchAndCachePut(request)\n            .catch(() => {\n            // Swallow this error because a 'no-response' error will be thrown in\n            // main handler return flow. This will be in the `waitUntil()` flow.\n        });\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this.cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                // NOTE(philipwalton): Really annoying that we have to type cast here.\n                // https://github.com/microsoft/TypeScript/issues/20006\n                response = await fetchAndCachePromise;\n            }\n            catch (err) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"],"names":["self","_","e","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","assert","isInstance","event","ExtendableEvent","moduleName","className","funcName","paramName","Object","assign","_strategy","_handlerDeferred","Deferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","fetch","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","logger","log","getFriendlyURL","url","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","WorkboxError","thrownError","pluginFilteredRequest","fetchResponse","undefined","fetchOptions","process","debug","status","callback","response","error","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","timeout","method","responseToCache","_ensureResponseSafeToCache","cache","open","hasCacheUpdateCallback","oldResponse","cacheMatchIgnoreParams","put","name","executeQuotaErrorCallbacks","newResponse","params","param","state","get","statefulCallback","statefulParam","push","doneWaiting","shift","destroy","resolve","pluginsUsed","warn","Strategy","cacheNames","getRuntimeName","handle","responseDone","handleAll","handler","_getResponse","handlerDone","_awaitComplete","_handle","type","waitUntilError","messages","strategyStart","strategyName","printFinalResponse","groupCollapsed","groupEnd","CacheFirst","logs","CacheOnly","cacheOkAndOpaquePlugin","cacheWillUpdate","NetworkFirst","some","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","isType","promises","timeoutId","id","_getTimeoutPromise","networkPromise","_getNetworkPromise","Promise","race","timeoutPromise","onNetworkTimeout","setTimeout","fetchError","clearTimeout","NetworkOnly","Error","StaleWhileRevalidate","fetchAndCachePromise","catch"],"mappings":";;;;;;;;;;;;;;;;;;;;;;EAEA,IAAI;EACAA,EAAAA,IAAI,CAAC,0BAAD,CAAJ,IAAoCC,CAAC,EAArC;EACH,CAFD,CAGA,OAAOC,CAAP,EAAU;;ECWV,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;EACtB,SAAQ,OAAOA,KAAP,KAAiB,QAAlB,GAA8B,IAAIC,OAAJ,CAAYD,KAAZ,CAA9B,GAAmDA,KAA1D;EACH;EACD;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,MAAME,eAAN,CAAsB;EAClB;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACIC,EAAAA,WAAW,CAACC,QAAD,EAAWC,OAAX,EAAoB;EAC3B,SAAKC,UAAL,GAAkB,EAAlB;EACA;EACR;EACA;EACA;EACA;EACA;EACA;EACA;;EACQ;EACR;EACA;EACA;EACA;EACA;EACA;;EACQ;EACR;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACQ;EACR;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACQ,IAA2C;EACvCC,MAAAA,gBAAM,CAACC,UAAP,CAAkBH,OAAO,CAACI,KAA1B,EAAiCC,eAAjC,EAAkD;EAC9CC,QAAAA,UAAU,EAAE,oBADkC;EAE9CC,QAAAA,SAAS,EAAE,iBAFmC;EAG9CC,QAAAA,QAAQ,EAAE,aAHoC;EAI9CC,QAAAA,SAAS,EAAE;EAJmC,OAAlD;EAMH;;EACDC,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBX,OAApB;EACA,SAAKI,KAAL,GAAaJ,OAAO,CAACI,KAArB;EACA,SAAKQ,SAAL,GAAiBb,QAAjB;EACA,SAAKc,gBAAL,GAAwB,IAAIC,oBAAJ,EAAxB;EACA,SAAKC,uBAAL,GAA+B,EAA/B,CAnD2B;EAqD3B;;EACA,SAAKC,QAAL,GAAgB,CAAC,GAAGjB,QAAQ,CAACkB,OAAb,CAAhB;EACA,SAAKC,eAAL,GAAuB,IAAIC,GAAJ,EAAvB;;EACA,SAAK,MAAMC,MAAX,IAAqB,KAAKJ,QAA1B,EAAoC;EAChC,WAAKE,eAAL,CAAqBG,GAArB,CAAyBD,MAAzB,EAAiC,EAAjC;EACH;;EACD,SAAKhB,KAAL,CAAWkB,SAAX,CAAqB,KAAKT,gBAAL,CAAsBU,OAA3C;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACIC,EAAAA,KAAK,CAAC7B,KAAD,EAAQ;EACT,WAAO,KAAK2B,SAAL,CAAe,CAAC,YAAY;EAC/B,YAAM;EAAElB,QAAAA;EAAF,UAAY,IAAlB;EACA,UAAIqB,OAAO,GAAG/B,SAAS,CAACC,KAAD,CAAvB;;EACA,UAAI8B,OAAO,CAACC,IAAR,KAAiB,UAAjB,IACAtB,KAAK,YAAYuB,UADjB,IAEAvB,KAAK,CAACwB,eAFV,EAE2B;EACvB,cAAMC,uBAAuB,GAAG,MAAMzB,KAAK,CAACwB,eAA5C;;EACA,YAAIC,uBAAJ,EAA6B;EACzB,UAA2C;EACvCC,YAAAA,gBAAM,CAACC,GAAP,CAAY,4CAAD,GACN,IAAGC,gCAAc,CAACP,OAAO,CAACQ,GAAT,CAAc,GADpC;EAEH;;EACD,iBAAOJ,uBAAP;EACH;EACJ,OAd8B;EAgB/B;EACA;;;EACA,YAAMK,eAAe,GAAG,KAAKC,WAAL,CAAiB,cAAjB,IACpBV,OAAO,CAACW,KAAR,EADoB,GACF,IADtB;;EAEA,UAAI;EACA,aAAK,MAAMC,EAAX,IAAiB,KAAKC,gBAAL,CAAsB,kBAAtB,CAAjB,EAA4D;EACxDb,UAAAA,OAAO,GAAG,MAAMY,EAAE,CAAC;EAAEZ,YAAAA,OAAO,EAAEA,OAAO,CAACW,KAAR,EAAX;EAA4BhC,YAAAA;EAA5B,WAAD,CAAlB;EACH;EACJ,OAJD,CAKA,OAAOmC,GAAP,EAAY;EACR,cAAM,IAAIC,4BAAJ,CAAiB,iCAAjB,EAAoD;EACtDC,UAAAA,WAAW,EAAEF;EADyC,SAApD,CAAN;EAGH,OA7B8B;EA+B/B;EACA;;;EACA,YAAMG,qBAAqB,GAAGjB,OAAO,CAACW,KAAR,EAA9B;;EACA,UAAI;EACA,YAAIO,aAAJ,CADA;;EAGAA,QAAAA,aAAa,GAAG,MAAMnB,KAAK,CAACC,OAAD,EAAUA,OAAO,CAACC,IAAR,KAAiB,UAAjB,GACjCkB,SADiC,GACrB,KAAKhC,SAAL,CAAeiC,YADJ,CAA3B;;EAEA,YAAIC,KAAA,KAAyB,YAA7B,EAA2C;EACvChB,UAAAA,gBAAM,CAACiB,KAAP,CAAc,sBAAD,GACR,IAAGf,gCAAc,CAACP,OAAO,CAACQ,GAAT,CAAc,6BADvB,GAER,WAAUU,aAAa,CAACK,MAAO,IAFpC;EAGH;;EACD,aAAK,MAAMC,QAAX,IAAuB,KAAKX,gBAAL,CAAsB,iBAAtB,CAAvB,EAAiE;EAC7DK,UAAAA,aAAa,GAAG,MAAMM,QAAQ,CAAC;EAC3B7C,YAAAA,KAD2B;EAE3BqB,YAAAA,OAAO,EAAEiB,qBAFkB;EAG3BQ,YAAAA,QAAQ,EAAEP;EAHiB,WAAD,CAA9B;EAKH;;EACD,eAAOA,aAAP;EACH,OAlBD,CAmBA,OAAOQ,KAAP,EAAc;EACV,QAA2C;EACvCrB,UAAAA,gBAAM,CAACqB,KAAP,CAAc,sBAAD,GACR,IAAGnB,gCAAc,CAACP,OAAO,CAACQ,GAAT,CAAc,mBADpC,EACwDkB,KADxD;EAEH,SAJS;EAMV;;;EACA,YAAIjB,eAAJ,EAAqB;EACjB,gBAAM,KAAKkB,YAAL,CAAkB,cAAlB,EAAkC;EACpCD,YAAAA,KADoC;EAEpC/C,YAAAA,KAFoC;EAGpC8B,YAAAA,eAAe,EAAEA,eAAe,CAACE,KAAhB,EAHmB;EAIpCX,YAAAA,OAAO,EAAEiB,qBAAqB,CAACN,KAAtB;EAJ2B,WAAlC,CAAN;EAMH;;EACD,cAAMe,KAAN;EACH;EACJ,KAtEqB,GAAf,CAAP;EAuEH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,QAAME,gBAAN,CAAuB1D,KAAvB,EAA8B;EAC1B,UAAMuD,QAAQ,GAAG,MAAM,KAAK1B,KAAL,CAAW7B,KAAX,CAAvB;EACA,UAAM2D,aAAa,GAAGJ,QAAQ,CAACd,KAAT,EAAtB;EACA,SAAKd,SAAL,CAAe,KAAKiC,QAAL,CAAc5D,KAAd,EAAqB2D,aAArB,CAAf;EACA,WAAOJ,QAAP;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACIM,EAAAA,UAAU,CAACC,GAAD,EAAM;EACZ,WAAO,KAAKnC,SAAL,CAAe,CAAC,YAAY;EAC/B,YAAMG,OAAO,GAAG/B,SAAS,CAAC+D,GAAD,CAAzB;EACA,UAAIC,cAAJ;EACA,YAAM;EAAEC,QAAAA,SAAF;EAAaC,QAAAA;EAAb,UAA8B,KAAKhD,SAAzC;EACA,YAAMiD,gBAAgB,GAAG,MAAM,KAAKC,WAAL,CAAiBrC,OAAjB,EAA0B,MAA1B,CAA/B;;EACA,YAAMsC,iBAAiB,gBAAQH,YAAR,EAAyB;EAAED,QAAAA;EAAF,OAAzB,CAAvB;;EACAD,MAAAA,cAAc,GAAG,MAAMM,MAAM,CAACC,KAAP,CAAaJ,gBAAb,EAA+BE,iBAA/B,CAAvB;;EACA,MAA2C;EACvC,YAAIL,cAAJ,EAAoB;EAChB5B,UAAAA,gBAAM,CAACiB,KAAP,CAAc,+BAA8BY,SAAU,IAAtD;EACH,SAFD,MAGK;EACD7B,UAAAA,gBAAM,CAACiB,KAAP,CAAc,gCAA+BY,SAAU,IAAvD;EACH;EACJ;;EACD,WAAK,MAAMV,QAAX,IAAuB,KAAKX,gBAAL,CAAsB,0BAAtB,CAAvB,EAA0E;EACtEoB,QAAAA,cAAc,GAAG,CAAC,MAAMT,QAAQ,CAAC;EAC7BU,UAAAA,SAD6B;EAE7BC,UAAAA,YAF6B;EAG7BF,UAAAA,cAH6B;EAI7BjC,UAAAA,OAAO,EAAEoC,gBAJoB;EAK7BzD,UAAAA,KAAK,EAAE,KAAKA;EALiB,SAAD,CAAf,KAMVwC,SANP;EAOH;;EACD,aAAOc,cAAP;EACH,KAzBqB,GAAf,CAAP;EA0BH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,QAAMH,QAAN,CAAeE,GAAf,EAAoBP,QAApB,EAA8B;EAC1B,UAAMzB,OAAO,GAAG/B,SAAS,CAAC+D,GAAD,CAAzB,CAD0B;EAG1B;;EACA,UAAMS,kBAAO,CAAC,CAAD,CAAb;EACA,UAAML,gBAAgB,GAAG,MAAM,KAAKC,WAAL,CAAiBrC,OAAjB,EAA0B,OAA1B,CAA/B;;EACA,IAA2C;EACvC,UAAIoC,gBAAgB,CAACM,MAAjB,IAA2BN,gBAAgB,CAACM,MAAjB,KAA4B,KAA3D,EAAkE;EAC9D,cAAM,IAAI3B,4BAAJ,CAAiB,kCAAjB,EAAqD;EACvDP,UAAAA,GAAG,EAAED,gCAAc,CAAC6B,gBAAgB,CAAC5B,GAAlB,CADoC;EAEvDkC,UAAAA,MAAM,EAAEN,gBAAgB,CAACM;EAF8B,SAArD,CAAN;EAIH;EACJ;;EACD,QAAI,CAACjB,QAAL,EAAe;EACX,MAA2C;EACvCpB,QAAAA,gBAAM,CAACqB,KAAP,CAAc,yCAAD,GACR,IAAGnB,gCAAc,CAAC6B,gBAAgB,CAAC5B,GAAlB,CAAuB,IAD7C;EAEH;;EACD,YAAM,IAAIO,4BAAJ,CAAiB,4BAAjB,EAA+C;EACjDP,QAAAA,GAAG,EAAED,gCAAc,CAAC6B,gBAAgB,CAAC5B,GAAlB;EAD8B,OAA/C,CAAN;EAGH;;EACD,UAAMmC,eAAe,GAAG,MAAM,KAAKC,0BAAL,CAAgCnB,QAAhC,CAA9B;;EACA,QAAI,CAACkB,eAAL,EAAsB;EAClB,MAA2C;EACvCtC,QAAAA,gBAAM,CAACiB,KAAP,CAAc,aAAYf,gCAAc,CAAC6B,gBAAgB,CAAC5B,GAAlB,CAAuB,IAAlD,GACR,qBADL,EAC2BmC,eAD3B;EAEH;;EACD,aAAO,KAAP;EACH;;EACD,UAAM;EAAET,MAAAA,SAAF;EAAaC,MAAAA;EAAb,QAA8B,KAAKhD,SAAzC;EACA,UAAM0D,KAAK,GAAG,MAAM/E,IAAI,CAACyE,MAAL,CAAYO,IAAZ,CAAiBZ,SAAjB,CAApB;EACA,UAAMa,sBAAsB,GAAG,KAAKrC,WAAL,CAAiB,gBAAjB,CAA/B;EACA,UAAMsC,WAAW,GAAGD,sBAAsB,GAAG,MAAME,gDAAsB;EAEzE;EACA;EACAJ,IAAAA,KAJyE,EAIlET,gBAAgB,CAACzB,KAAjB,EAJkE,EAIxC,CAAC,iBAAD,CAJwC,EAInBwB,YAJmB,CAA/B,GAKtC,IALJ;;EAMA,IAA2C;EACvC9B,MAAAA,gBAAM,CAACiB,KAAP,CAAc,iBAAgBY,SAAU,8BAA3B,GACR,OAAM3B,gCAAc,CAAC6B,gBAAgB,CAAC5B,GAAlB,CAAuB,GADhD;EAEH;;EACD,QAAI;EACA,YAAMqC,KAAK,CAACK,GAAN,CAAUd,gBAAV,EAA4BW,sBAAsB,GACpDJ,eAAe,CAAChC,KAAhB,EADoD,GAC1BgC,eADxB,CAAN;EAEH,KAHD,CAIA,OAAOjB,KAAP,EAAc;EACV;EACA,UAAIA,KAAK,CAACyB,IAAN,KAAe,oBAAnB,EAAyC;EACrC,cAAMC,wDAA0B,EAAhC;EACH;;EACD,YAAM1B,KAAN;EACH;;EACD,SAAK,MAAMF,QAAX,IAAuB,KAAKX,gBAAL,CAAsB,gBAAtB,CAAvB,EAAgE;EAC5D,YAAMW,QAAQ,CAAC;EACXU,QAAAA,SADW;EAEXc,QAAAA,WAFW;EAGXK,QAAAA,WAAW,EAAEV,eAAe,CAAChC,KAAhB,EAHF;EAIXX,QAAAA,OAAO,EAAEoC,gBAJE;EAKXzD,QAAAA,KAAK,EAAE,KAAKA;EALD,OAAD,CAAd;EAOH;;EACD,WAAO,IAAP;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,QAAM0D,WAAN,CAAkBrC,OAAlB,EAA2BC,IAA3B,EAAiC;EAC7B,QAAI,CAAC,KAAKzB,UAAL,CAAgByB,IAAhB,CAAL,EAA4B;EACxB,UAAImC,gBAAgB,GAAGpC,OAAvB;;EACA,WAAK,MAAMwB,QAAX,IAAuB,KAAKX,gBAAL,CAAsB,oBAAtB,CAAvB,EAAoE;EAChEuB,QAAAA,gBAAgB,GAAGnE,SAAS,CAAC,MAAMuD,QAAQ,CAAC;EACxCvB,UAAAA,IADwC;EAExCD,UAAAA,OAAO,EAAEoC,gBAF+B;EAGxCzD,UAAAA,KAAK,EAAE,KAAKA,KAH4B;EAIxC2E,UAAAA,MAAM,EAAE,KAAKA;EAJ2B,SAAD,CAAf,CAA5B;EAMH;;EACD,WAAK9E,UAAL,CAAgByB,IAAhB,IAAwBmC,gBAAxB;EACH;;EACD,WAAO,KAAK5D,UAAL,CAAgByB,IAAhB,CAAP;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;;;EACIS,EAAAA,WAAW,CAACyC,IAAD,EAAO;EACd,SAAK,MAAMxD,MAAX,IAAqB,KAAKR,SAAL,CAAeK,OAApC,EAA6C;EACzC,UAAI2D,IAAI,IAAIxD,MAAZ,EAAoB;EAChB,eAAO,IAAP;EACH;EACJ;;EACD,WAAO,KAAP;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,QAAMgC,YAAN,CAAmBwB,IAAnB,EAAyBI,KAAzB,EAAgC;EAC5B,SAAK,MAAM/B,QAAX,IAAuB,KAAKX,gBAAL,CAAsBsC,IAAtB,CAAvB,EAAoD;EAChD;EACA;EACA,YAAM3B,QAAQ,CAAC+B,KAAD,CAAd;EACH;EACJ;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,GAAC1C,gBAAD,CAAkBsC,IAAlB,EAAwB;EACpB,SAAK,MAAMxD,MAAX,IAAqB,KAAKR,SAAL,CAAeK,OAApC,EAA6C;EACzC,UAAI,OAAOG,MAAM,CAACwD,IAAD,CAAb,KAAwB,UAA5B,EAAwC;EACpC,cAAMK,KAAK,GAAG,KAAK/D,eAAL,CAAqBgE,GAArB,CAAyB9D,MAAzB,CAAd;;EACA,cAAM+D,gBAAgB,GAAIH,KAAD,IAAW;EAChC,gBAAMI,aAAa,gBAAQJ,KAAR;EAAeC,YAAAA;EAAf,YAAnB,CADgC;EAGhC;;;EACA,iBAAO7D,MAAM,CAACwD,IAAD,CAAN,CAAaQ,aAAb,CAAP;EACH,SALD;;EAMA,cAAMD,gBAAN;EACH;EACJ;EACJ;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI7D,EAAAA,SAAS,CAACC,OAAD,EAAU;EACf,SAAKR,uBAAL,CAA6BsE,IAA7B,CAAkC9D,OAAlC;;EACA,WAAOA,OAAP;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,QAAM+D,WAAN,GAAoB;EAChB,QAAI/D,OAAJ;;EACA,WAAOA,OAAO,GAAG,KAAKR,uBAAL,CAA6BwE,KAA7B,EAAjB,EAAuD;EACnD,YAAMhE,OAAN;EACH;EACJ;EACD;EACJ;EACA;EACA;;;EACIiE,EAAAA,OAAO,GAAG;EACN,SAAK3E,gBAAL,CAAsB4E,OAAtB;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACI,QAAMpB,0BAAN,CAAiCnB,QAAjC,EAA2C;EACvC,QAAIkB,eAAe,GAAGlB,QAAtB;EACA,QAAIwC,WAAW,GAAG,KAAlB;;EACA,SAAK,MAAMzC,QAAX,IAAuB,KAAKX,gBAAL,CAAsB,iBAAtB,CAAvB,EAAiE;EAC7D8B,MAAAA,eAAe,GAAG,CAAC,MAAMnB,QAAQ,CAAC;EAC9BxB,QAAAA,OAAO,EAAE,KAAKA,OADgB;EAE9ByB,QAAAA,QAAQ,EAAEkB,eAFoB;EAG9BhE,QAAAA,KAAK,EAAE,KAAKA;EAHkB,OAAD,CAAf,KAIXwC,SAJP;EAKA8C,MAAAA,WAAW,GAAG,IAAd;;EACA,UAAI,CAACtB,eAAL,EAAsB;EAClB;EACH;EACJ;;EACD,QAAI,CAACsB,WAAL,EAAkB;EACd,UAAItB,eAAe,IAAIA,eAAe,CAACpB,MAAhB,KAA2B,GAAlD,EAAuD;EACnDoB,QAAAA,eAAe,GAAGxB,SAAlB;EACH;;EACD,MAA2C;EACvC,YAAIwB,eAAJ,EAAqB;EACjB,cAAIA,eAAe,CAACpB,MAAhB,KAA2B,GAA/B,EAAoC;EAChC,gBAAIoB,eAAe,CAACpB,MAAhB,KAA2B,CAA/B,EAAkC;EAC9BlB,cAAAA,gBAAM,CAAC6D,IAAP,CAAa,qBAAoB,KAAKlE,OAAL,CAAaQ,GAAI,IAAtC,GACP,0DADO,GAEP,mDAFL;EAGH,aAJD,MAKK;EACDH,cAAAA,gBAAM,CAACiB,KAAP,CAAc,qBAAoB,KAAKtB,OAAL,CAAaQ,GAAI,IAAtC,GACR,8BAA6BiB,QAAQ,CAACF,MAAO,cADrC,GAER,wBAFL;EAGH;EACJ;EACJ;EACJ;EACJ;;EACD,WAAOoB,eAAP;EACH;;EA3diB;;EC5BtB;EACA;AACA;EACA;EACA;EACA;EACA;AACA,EAMA;EACA;EACA;EACA;EACA;;EACA,MAAMwB,QAAN,CAAe;EACX;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACI9F,EAAAA,WAAW,CAACE,OAAO,GAAG,EAAX,EAAe;EACtB;EACR;EACA;EACA;EACA;EACA;EACA;EACQ,SAAK2D,SAAL,GAAiBkC,wBAAU,CAACC,cAAX,CAA0B9F,OAAO,CAAC2D,SAAlC,CAAjB;EACA;EACR;EACA;EACA;EACA;EACA;EACA;;EACQ,SAAK1C,OAAL,GAAejB,OAAO,CAACiB,OAAR,IAAmB,EAAlC;EACA;EACR;EACA;EACA;EACA;EACA;EACA;;EACQ,SAAK4B,YAAL,GAAoB7C,OAAO,CAAC6C,YAA5B;EACA;EACR;EACA;EACA;EACA;EACA;EACA;;EACQ,SAAKe,YAAL,GAAoB5D,OAAO,CAAC4D,YAA5B;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACImC,EAAAA,MAAM,CAAC/F,OAAD,EAAU;EACZ,UAAM,CAACgG,YAAD,IAAiB,KAAKC,SAAL,CAAejG,OAAf,CAAvB;EACA,WAAOgG,YAAP;EACH;EACD;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACIC,EAAAA,SAAS,CAACjG,OAAD,EAAU;EACf;EACA,QAAIA,OAAO,YAAY2B,UAAvB,EAAmC;EAC/B3B,MAAAA,OAAO,GAAG;EACNI,QAAAA,KAAK,EAAEJ,OADD;EAENyB,QAAAA,OAAO,EAAEzB,OAAO,CAACyB;EAFX,OAAV;EAIH;;EACD,UAAMrB,KAAK,GAAGJ,OAAO,CAACI,KAAtB;EACA,UAAMqB,OAAO,GAAG,OAAOzB,OAAO,CAACyB,OAAf,KAA2B,QAA3B,GACZ,IAAI7B,OAAJ,CAAYI,OAAO,CAACyB,OAApB,CA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"}